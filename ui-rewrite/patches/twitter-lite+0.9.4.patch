diff --git a/node_modules/twitter-lite/.DS_Store b/node_modules/twitter-lite/.DS_Store
new file mode 100644
index 0000000..3c653fe
Binary files /dev/null and b/node_modules/twitter-lite/.DS_Store differ
diff --git a/node_modules/twitter-lite/dist/twitter.js b/node_modules/twitter-lite/dist/twitter.js
index 5b76ee2..5c88020 100644
--- a/node_modules/twitter-lite/dist/twitter.js
+++ b/node_modules/twitter-lite/dist/twitter.js
@@ -1,2 +1,2 @@
-var e=require("crypto"),t=require("oauth-1.0a"),r=require("cross-fetch"),n=require("querystring"),s=require("./stream"),o=function(e,t){return void 0===t&&(t="1.1"),"https://"+e+".twitter.com/"+t},i={subdomain:"api",consumer_key:null,consumer_secret:null,access_token_key:null,access_token_secret:null,bearer_token:null},a=["direct_messages/events/new","direct_messages/welcome_messages/new","direct_messages/welcome_messages/rules/new"],u={"Content-Type":"application/json",Accept:"application/json"};function c(e){return e.replace(/!/g,"%21").replace(/\*/g,"%2A").replace(/'/g,"%27").replace(/\(/g,"%28").replace(/\)/g,"%29")}var h=function(r){var n,s=Object.assign({},i,r);this.authType=s.bearer_token?"App":"User",this.client=t({consumer:{key:(n={key:s.consumer_key,secret:s.consumer_secret}).key,secret:n.secret},signature_method:"HMAC-SHA1",hash_function:function(t,r){return e.createHmac("sha1",r).update(t).digest("base64")}}),this.token={key:s.access_token_key,secret:s.access_token_secret},this.url=o(s.subdomain),this.oauth=o(s.subdomain,"oauth"),this.config=s};h._handleResponse=function(e){var t=e.headers.raw();return 204===e.status?{_headers:t}:e.json().then(function(e){return e._headers=t,e})},h.prototype.getBearerToken=function(){return new Promise(function(e,t){var n;return n={Authorization:"Basic "+Buffer.from(this.config.consumer_key+":"+this.config.consumer_secret).toString("base64"),"Content-Type":"application/x-www-form-urlencoded;charset=UTF-8"},r("https://api.twitter.com/oauth2/token",{method:"POST",body:"grant_type=client_credentials",headers:n}).then(h._handleResponse).then(function(r){try{return e(r)}catch(e){return t(e)}},t)}.bind(this))},h.prototype.getRequestToken=function(e){return new Promise(function(t,s){var o,i,a;return o={url:this.oauth+"/request_token",method:"POST"},i={},e&&(i={oauth_callback:e}),i&&(o.url+="?"+n.stringify(i)),a=this.client.toHeader(this.client.authorize(o,{})),r(o.url,{method:"POST",headers:Object.assign({},u,a)}).then(function(e){return e.text()}).then(function(e){return n.parse(e)}).then(function(e){try{return t(e)}catch(e){return s(e)}},s)}.bind(this))},h.prototype.getAccessToken=function(e){return new Promise(function(t,s){var o,i,a;return o={url:this.oauth+"/access_token",method:"POST"},(i={oauth_verifier:e.verifier})&&(o.url+="?"+n.stringify(i)),a=this.client.toHeader(this.client.authorize(o,{key:e.key,secret:e.secret})),r(o.url,{method:"POST",headers:Object.assign({},u,a)}).then(function(e){return e.text()}).then(function(e){return n.parse(e)}).then(function(e){try{return t(e)}catch(e){return s(e)}},s)}.bind(this))},h.prototype._makeRequest=function(e,t,r){var s={url:this.url+"/"+t+".json",method:e};r&&("POST"===e?s.data=r:s.url+="?"+n.stringify(r));return{requestData:s,headers:"User"===this.authType?this.client.toHeader(this.client.authorize(s,this.token)):{Authorization:"Bearer "+this.config.bearer_token}}},h.prototype.get=function(e,t){var n=this._makeRequest("GET",e,t);return r(n.requestData.url,{headers:n.headers}).then(h._handleResponse).then(function(e){return"errors"in e?Promise.reject(e):e})},h.prototype.post=function(e,t){var s=this._makeRequest("POST",e,a.includes(e)?null:t),o=s.requestData,i=Object.assign({},u,s.headers);return a.includes(e)?t=JSON.stringify(t):(t=c(n.stringify(t)),i["Content-Type"]="application/x-www-form-urlencoded"),r(o.url,{method:"POST",headers:i,body:t}).then(h._handleResponse).then(function(e){return"errors"in e?Promise.reject(e):e})},h.prototype.stream=function(e,t){var i=this;if("User"!==this.authType)throw new Error("Streams require user context authentication");var a=new s,u={url:o("stream")+"/"+e+".json",method:"POST"};t&&(u.data=t);var h=this.client.toHeader(this.client.authorize(u,this.token));return r(u.url,{method:"POST",headers:Object.assign({},h,{"Content-Type":"application/x-www-form-urlencoded"}),body:c(n.stringify(t))}).then(function(e){a.destroy=i.stream.destroy=function(){return e.body.destroy()},e.ok?a.emit("start",e):(e._headers=e.headers.raw(),a.emit("error",e)),e.body.on("data",function(e){return a.parse(e)}).on("error",function(e){return a.emit("error",e)}).on("end",function(){return a.emit("end",e)})}).catch(function(e){return a.emit("error",e)}),a},module.exports=h;
+var e=require("crypto"),t=require("oauth-1.0a"),r=require("cross-fetch"),n=require("querystring"),s=require("./stream"),o=function(e,t){return void 0===t&&(t="1.1"),"https://"+e+".twitter.com/"+t},i={subdomain:"api",consumer_key:null,consumer_secret:null,access_token_key:null,access_token_secret:null,bearer_token:null},a=["direct_messages/events/new","direct_messages/welcome_messages/new","direct_messages/welcome_messages/rules/new"],u={"Content-Type":"application/json",Accept:"application/json"};function c(e){return e.replace(/!/g,"%21").replace(/\*/g,"%2A").replace(/'/g,"%27").replace(/\(/g,"%28").replace(/\)/g,"%29")}var h=function(r){var n,s=Object.assign({},i,r);this.authType=s.bearer_token?"App":"User",this.client=t({consumer:{key:(n={key:s.consumer_key,secret:s.consumer_secret}).key,secret:n.secret},signature_method:"HMAC-SHA1",hash_function:function(t,r){return e.createHmac("sha1",r).update(t).digest("base64")}}),this.token={key:s.access_token_key,secret:s.access_token_secret},this.url=o(s.subdomain),this.oauth=o(s.subdomain,"oauth"),this.config=s};h._handleResponse=function(e){var t=e.headers;return 204===e.status?{_headers:t}:e.json().then(function(e){return e._headers=t,e})},h.prototype.getBearerToken=function(){return new Promise(function(e,t){var n;return n={Authorization:"Basic "+Buffer.from(this.config.consumer_key+":"+this.config.consumer_secret).toString("base64"),"Content-Type":"application/x-www-form-urlencoded;charset=UTF-8"},r("https://api.twitter.com/oauth2/token",{method:"POST",body:"grant_type=client_credentials",headers:n}).then(h._handleResponse).then(function(r){try{return e(r)}catch(e){return t(e)}},t)}.bind(this))},h.prototype.getRequestToken=function(e){return new Promise(function(t,s){var o,i,a;return o={url:this.oauth+"/request_token",method:"POST"},i={},e&&(i={oauth_callback:e}),i&&(o.url+="?"+n.stringify(i)),a=this.client.toHeader(this.client.authorize(o,{})),r(o.url,{method:"POST",headers:Object.assign({},u,a)}).then(function(e){return e.text()}).then(function(e){return n.parse(e)}).then(function(e){try{return t(e)}catch(e){return s(e)}},s)}.bind(this))},h.prototype.getAccessToken=function(e){return new Promise(function(t,s){var o,i,a;return o={url:this.oauth+"/access_token",method:"POST"},(i={oauth_verifier:e.verifier})&&(o.url+="?"+n.stringify(i)),a=this.client.toHeader(this.client.authorize(o,{key:e.key,secret:e.secret})),r(o.url,{method:"POST",headers:Object.assign({},u,a)}).then(function(e){return e.text()}).then(function(e){return n.parse(e)}).then(function(e){try{return t(e)}catch(e){return s(e)}},s)}.bind(this))},h.prototype._makeRequest=function(e,t,r){var s={url:this.url+"/"+t+".json",method:e};r&&("POST"===e?s.data=r:s.url+="?"+n.stringify(r));return{requestData:s,headers:"User"===this.authType?this.client.toHeader(this.client.authorize(s,this.token)):{Authorization:"Bearer "+this.config.bearer_token}}},h.prototype.get=function(e,t){var n=this._makeRequest("GET",e,t);return r(n.requestData.url,{headers:n.headers}).then(h._handleResponse).then(function(e){return"errors"in e?Promise.reject(e):e})},h.prototype.post=function(e,t){var s=this._makeRequest("POST",e,a.includes(e)?null:t),o=s.requestData,i=Object.assign({},u,s.headers);return a.includes(e)?t=JSON.stringify(t):(t=c(n.stringify(t)),i["Content-Type"]="application/x-www-form-urlencoded"),r(o.url,{method:"POST",headers:i,body:t}).then(h._handleResponse).then(function(e){return"errors"in e?Promise.reject(e):e})},h.prototype.stream=function(e,t){var i=this;if("User"!==this.authType)throw new Error("Streams require user context authentication");var a=new s,u={url:o("stream")+"/"+e+".json",method:"POST"};t&&(u.data=t);var h=this.client.toHeader(this.client.authorize(u,this.token));return r(u.url,{method:"POST",headers:Object.assign({},h,{"Content-Type":"application/x-www-form-urlencoded"}),body:c(n.stringify(t))}).then(function(e){a.destroy=i.stream.destroy=function(){return e.body.destroy()},e.ok?a.emit("start",e):(e._headers=e.headers,a.emit("error",e)),e.body.on("data",function(e){return a.parse(e)}).on("error",function(e){return a.emit("error",e)}).on("end",function(){return a.emit("end",e)})}).catch(function(e){return a.emit("error",e)}),a},module.exports=h;
 //# sourceMappingURL=twitter.js.map
diff --git a/node_modules/twitter-lite/dist/twitter.js.map b/node_modules/twitter-lite/dist/twitter.js.map
index cebbd62..4b39682 100644
--- a/node_modules/twitter-lite/dist/twitter.js.map
+++ b/node_modules/twitter-lite/dist/twitter.js.map
@@ -1 +1 @@
-{"version":3,"file":"twitter.js","sources":["../twitter.js"],"sourcesContent":["const crypto = require('crypto');\nconst OAuth = require('oauth-1.0a');\nconst Fetch = require('cross-fetch');\nconst querystring = require('querystring');\nconst Stream = require('./stream');\n\nconst getUrl = (subdomain, endpoint = '1.1') =>\n  `https://${subdomain}.twitter.com/${endpoint}`;\n\nconst createOauthClient = ({ key, secret }) => {\n  const client = OAuth({\n    consumer: { key, secret },\n    signature_method: 'HMAC-SHA1',\n    hash_function(baseString, key) {\n      return crypto\n        .createHmac('sha1', key)\n        .update(baseString)\n        .digest('base64');\n    },\n  });\n\n  return client;\n};\n\nconst defaults = {\n  subdomain: 'api',\n  consumer_key: null,\n  consumer_secret: null,\n  access_token_key: null,\n  access_token_secret: null,\n  bearer_token: null,\n};\n\n// Twitter expects POST body parameters to be URL-encoded: https://developer.twitter.com/en/docs/basics/authentication/guides/creating-a-signature\n// However, some endpoints expect a JSON payload - https://developer.twitter.com/en/docs/direct-messages/sending-and-receiving/api-reference/new-event\n// It appears that JSON payloads don't need to be included in the signature,\n// because sending DMs works without signing the POST body\nconst JSON_ENDPOINTS = [\n  'direct_messages/events/new',\n  'direct_messages/welcome_messages/new',\n  'direct_messages/welcome_messages/rules/new',\n];\n\nconst baseHeaders = {\n  'Content-Type': 'application/json',\n  Accept: 'application/json',\n};\n\nfunction percentEncode(string) {\n  // From OAuth.prototype.percentEncode\n  return string\n    .replace(/!/g, '%21')\n    .replace(/\\*/g, '%2A')\n    .replace(/'/g, '%27')\n    .replace(/\\(/g, '%28')\n    .replace(/\\)/g, '%29');\n}\n\nclass Twitter {\n  constructor(options) {\n    const config = Object.assign({}, defaults, options);\n    this.authType = config.bearer_token ? 'App' : 'User';\n    this.client = createOauthClient({\n      key: config.consumer_key,\n      secret: config.consumer_secret,\n    });\n\n    this.token = {\n      key: config.access_token_key,\n      secret: config.access_token_secret,\n    };\n\n    this.url = getUrl(config.subdomain);\n    this.oauth = getUrl(config.subdomain, 'oauth');\n    this.config = config;\n  }\n\n  /**\n   * Parse the JSON from a Response object and add the Headers under `_headers`\n   * @param {Response} response - the Response object returned by Fetch\n   * @return {Promise<object>}\n   * @private\n   */\n  static _handleResponse(response) {\n    const headers = response.headers.raw(); // TODO: see #44\n    // Return empty response on 204 \"No content\"\n    if (response.status === 204)\n      return {\n        _headers: headers,\n      };\n    // Otherwise, parse JSON response\n    return response.json().then(res => {\n      res._headers = headers; // TODO: this creates an array-like object when it adds _headers to an array response\n      return res;\n    });\n  }\n\n  async getBearerToken() {\n    const headers = {\n      Authorization:\n        'Basic ' +\n        Buffer.from(\n          this.config.consumer_key + ':' + this.config.consumer_secret\n        ).toString('base64'),\n      'Content-Type': 'application/x-www-form-urlencoded;charset=UTF-8',\n    };\n\n    const results = await Fetch('https://api.twitter.com/oauth2/token', {\n      method: 'POST',\n      body: 'grant_type=client_credentials',\n      headers,\n    }).then(Twitter._handleResponse);\n\n    return results;\n  }\n\n  async getRequestToken(twitterCallbackUrl) {\n    const requestData = {\n      url: `${this.oauth}/request_token`,\n      method: 'POST',\n    };\n\n    let parameters = {};\n    if (twitterCallbackUrl) parameters = { oauth_callback: twitterCallbackUrl };\n    if (parameters) requestData.url += '?' + querystring.stringify(parameters);\n\n    const headers = this.client.toHeader(\n      this.client.authorize(requestData, {})\n    );\n\n    const results = await Fetch(requestData.url, {\n      method: 'POST',\n      headers: Object.assign({}, baseHeaders, headers),\n    })\n      .then(res => res.text())\n      .then(txt => querystring.parse(txt));\n\n    return results;\n  }\n\n  async getAccessToken(options) {\n    const requestData = {\n      url: `${this.oauth}/access_token`,\n      method: 'POST',\n    };\n\n    let parameters = { oauth_verifier: options.verifier };\n    if (parameters) requestData.url += '?' + querystring.stringify(parameters);\n\n    const headers = this.client.toHeader(\n      this.client.authorize(requestData, {\n        key: options.key,\n        secret: options.secret,\n      })\n    );\n\n    const results = await Fetch(requestData.url, {\n      method: 'POST',\n      headers: Object.assign({}, baseHeaders, headers),\n    })\n      .then(res => res.text())\n      .then(txt => querystring.parse(txt));\n\n    return results;\n  }\n\n  /**\n   * Construct the data and headers for an authenticated HTTP request to the Twitter API\n   * @param {string} method - 'GET' or 'POST'\n   * @param {string} resource - the API endpoint\n   * @param {object} parameters\n   * @return {{requestData: {url: string, method: string}, headers: ({Authorization: string}|OAuth.Header)}}\n   * @private\n   */\n  _makeRequest(method, resource, parameters) {\n    const requestData = {\n      url: `${this.url}/${resource}.json`,\n      method,\n    };\n    if (parameters)\n      if (method === 'POST') requestData.data = parameters;\n      else requestData.url += '?' + querystring.stringify(parameters);\n\n    let headers = {};\n    if (this.authType === 'User') {\n      headers = this.client.toHeader(\n        this.client.authorize(requestData, this.token)\n      );\n    } else {\n      headers = {\n        Authorization: `Bearer ${this.config.bearer_token}`,\n      };\n    }\n    return {\n      requestData,\n      headers,\n    };\n  }\n\n  /**\n   * Send a GET request\n   * @param {string} resource - endpoint, e.g. `followers/ids`\n   * @param {object} [parameters] - optional parameters\n   * @returns {Promise<object>} Promise resolving to the response from the Twitter API.\n   *   The `_header` property will be set to the Response headers (useful for checking rate limits)\n   */\n  get(resource, parameters) {\n    const { requestData, headers } = this._makeRequest(\n      'GET',\n      resource,\n      parameters\n    );\n\n    return Fetch(requestData.url, { headers })\n      .then(Twitter._handleResponse)\n      .then(results =>\n        'errors' in results ? Promise.reject(results) : results\n      );\n  }\n\n  /**\n   * Send a POST request\n   * @param {string} resource - endpoint, e.g. `users/lookup`\n   * @param {object} body - POST parameters object.\n   *   Will be encoded appropriately (JSON or urlencoded) based on the resource\n   * @returns {Promise<object>} Promise resolving to the response from the Twitter API.\n   *   The `_header` property will be set to the Response headers (useful for checking rate limits)\n   */\n  post(resource, body) {\n    const { requestData, headers } = this._makeRequest(\n      'POST',\n      resource,\n      JSON_ENDPOINTS.includes(resource) ? null : body // don't sign JSON bodies; only parameters\n    );\n\n    const postHeaders = Object.assign({}, baseHeaders, headers);\n    if (JSON_ENDPOINTS.includes(resource)) {\n      body = JSON.stringify(body);\n    } else {\n      body = percentEncode(querystring.stringify(body));\n      postHeaders['Content-Type'] = 'application/x-www-form-urlencoded';\n    }\n\n    return Fetch(requestData.url, {\n      method: 'POST',\n      headers: postHeaders,\n      body,\n    })\n      .then(Twitter._handleResponse)\n      .then(results =>\n        'errors' in results ? Promise.reject(results) : results\n      );\n  }\n\n  /**\n   *\n   * @param {string} resource - endpoint, e.g. `statuses/filter`\n   * @param {object} parameters\n   * @returns {Stream}\n   */\n  stream(resource, parameters) {\n    if (this.authType !== 'User')\n      throw new Error('Streams require user context authentication');\n\n    const stream = new Stream();\n\n    // POST the request, in order to accommodate long parameter lists, e.g.\n    // up to 5000 ids for statuses/filter - https://developer.twitter.com/en/docs/tweets/filter-realtime/api-reference/post-statuses-filter\n    const requestData = {\n      url: `${getUrl('stream')}/${resource}.json`,\n      method: 'POST',\n    };\n    if (parameters) requestData.data = parameters;\n\n    const headers = this.client.toHeader(\n      this.client.authorize(requestData, this.token)\n    );\n\n    const request = Fetch(requestData.url, {\n      method: 'POST',\n      headers: {\n        ...headers,\n        'Content-Type': 'application/x-www-form-urlencoded',\n      },\n      body: percentEncode(querystring.stringify(parameters)),\n    });\n\n    request\n      .then(response => {\n        stream.destroy = this.stream.destroy = () => response.body.destroy();\n\n        if (response.ok) {\n          stream.emit('start', response);\n        } else {\n          response._headers = response.headers.raw();  // TODO: see #44 - could omit the line\n          stream.emit('error', response);\n        }\n\n        response.body\n          .on('data', chunk => stream.parse(chunk))\n          .on('error', error => stream.emit('error', error))  // no point in adding the original response headers\n          .on('end', () => stream.emit('end', response));\n      })\n      .catch(error => stream.emit('error', error));\n\n    return stream;\n  }\n}\n\nmodule.exports = Twitter;\n"],"names":["const","crypto","require","OAuth","Fetch","querystring","Stream","getUrl","subdomain","endpoint","defaults","consumer_key","consumer_secret","access_token_key","access_token_secret","bearer_token","JSON_ENDPOINTS","baseHeaders","Content-Type","Accept","percentEncode","string","replace","Twitter","options","ref","config","Object","assign","authType","client","consumer","signature_method","hash_function","baseString","key","createHmac","update","digest","token","url","oauth","_handleResponse","response","headers","raw","status","json","then","res","_headers","getBearerToken","Buffer","from","this","toString","$await_1","getRequestToken","twitterCallbackUrl","parameters","requestData","stringify","toHeader","authorize","text","txt","parse","$await_2","getAccessToken","verifier","secret","$await_3","_makeRequest","method","resource","data","get","results","Promise","reject","post","body","includes","postHeaders","JSON","stream","Error","destroy","ok","emit","on","chunk","error","catch","module","exports"],"mappings":"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"}
\ No newline at end of file
+{"version":3,"file":"twitter.js","sources":["../twitter.js"],"sourcesContent":["const crypto = require('crypto');\nconst OAuth = require('oauth-1.0a');\nconst Fetch = require('cross-fetch');\nconst querystring = require('querystring');\nconst Stream = require('./stream');\n\nconst getUrl = (subdomain, endpoint = '1.1') =>\n  `https://${subdomain}.twitter.com/${endpoint}`;\n\nconst createOauthClient = ({ key, secret }) => {\n  const client = OAuth({\n    consumer: { key, secret },\n    signature_method: 'HMAC-SHA1',\n    hash_function(baseString, key) {\n      return crypto\n        .createHmac('sha1', key)\n        .update(baseString)\n        .digest('base64');\n    },\n  });\n\n  return client;\n};\n\nconst defaults = {\n  subdomain: 'api',\n  consumer_key: null,\n  consumer_secret: null,\n  access_token_key: null,\n  access_token_secret: null,\n  bearer_token: null,\n};\n\n// Twitter expects POST body parameters to be URL-encoded: https://developer.twitter.com/en/docs/basics/authentication/guides/creating-a-signature\n// However, some endpoints expect a JSON payload - https://developer.twitter.com/en/docs/direct-messages/sending-and-receiving/api-reference/new-event\n// It appears that JSON payloads don't need to be included in the signature,\n// because sending DMs works without signing the POST body\nconst JSON_ENDPOINTS = [\n  'direct_messages/events/new',\n  'direct_messages/welcome_messages/new',\n  'direct_messages/welcome_messages/rules/new',\n];\n\nconst baseHeaders = {\n  'Content-Type': 'application/json',\n  Accept: 'application/json',\n};\n\nfunction percentEncode(string) {\n  // From OAuth.prototype.percentEncode\n  return string\n    .replace(/!/g, '%21')\n    .replace(/\\*/g, '%2A')\n    .replace(/'/g, '%27')\n    .replace(/\\(/g, '%28')\n    .replace(/\\)/g, '%29');\n}\n\nclass Twitter {\n  constructor(options) {\n    const config = Object.assign({}, defaults, options);\n    this.authType = config.bearer_token ? 'App' : 'User';\n    this.client = createOauthClient({\n      key: config.consumer_key,\n      secret: config.consumer_secret,\n    });\n\n    this.token = {\n      key: config.access_token_key,\n      secret: config.access_token_secret,\n    };\n\n    this.url = getUrl(config.subdomain);\n    this.oauth = getUrl(config.subdomain, 'oauth');\n    this.config = config;\n  }\n\n  /**\n   * Parse the JSON from a Response object and add the Headers under `_headers`\n   * @param {Response} response - the Response object returned by Fetch\n   * @return {Promise<object>}\n   * @private\n   */\n  static _handleResponse(response) {\n    const headers = response.headers; // TODO: see #44\n    // Return empty response on 204 \"No content\"\n    if (response.status === 204)\n      return {\n        _headers: headers,\n      };\n    // Otherwise, parse JSON response\n    return response.json().then(res => {\n      res._headers = headers; // TODO: this creates an array-like object when it adds _headers to an array response\n      return res;\n    });\n  }\n\n  async getBearerToken() {\n    const headers = {\n      Authorization:\n        'Basic ' +\n        Buffer.from(\n          this.config.consumer_key + ':' + this.config.consumer_secret\n        ).toString('base64'),\n      'Content-Type': 'application/x-www-form-urlencoded;charset=UTF-8',\n    };\n\n    const results = await Fetch('https://api.twitter.com/oauth2/token', {\n      method: 'POST',\n      body: 'grant_type=client_credentials',\n      headers,\n    }).then(Twitter._handleResponse);\n\n    return results;\n  }\n\n  async getRequestToken(twitterCallbackUrl) {\n    const requestData = {\n      url: `${this.oauth}/request_token`,\n      method: 'POST',\n    };\n\n    let parameters = {};\n    if (twitterCallbackUrl) parameters = { oauth_callback: twitterCallbackUrl };\n    if (parameters) requestData.url += '?' + querystring.stringify(parameters);\n\n    const headers = this.client.toHeader(\n      this.client.authorize(requestData, {})\n    );\n\n    const results = await Fetch(requestData.url, {\n      method: 'POST',\n      headers: Object.assign({}, baseHeaders, headers),\n    })\n      .then(res => res.text())\n      .then(txt => querystring.parse(txt));\n\n    return results;\n  }\n\n  async getAccessToken(options) {\n    const requestData = {\n      url: `${this.oauth}/access_token`,\n      method: 'POST',\n    };\n\n    let parameters = { oauth_verifier: options.verifier };\n    if (parameters) requestData.url += '?' + querystring.stringify(parameters);\n\n    const headers = this.client.toHeader(\n      this.client.authorize(requestData, {\n        key: options.key,\n        secret: options.secret,\n      })\n    );\n\n    const results = await Fetch(requestData.url, {\n      method: 'POST',\n      headers: Object.assign({}, baseHeaders, headers),\n    })\n      .then(res => res.text())\n      .then(txt => querystring.parse(txt));\n\n    return results;\n  }\n\n  /**\n   * Construct the data and headers for an authenticated HTTP request to the Twitter API\n   * @param {string} method - 'GET' or 'POST'\n   * @param {string} resource - the API endpoint\n   * @param {object} parameters\n   * @return {{requestData: {url: string, method: string}, headers: ({Authorization: string}|OAuth.Header)}}\n   * @private\n   */\n  _makeRequest(method, resource, parameters) {\n    const requestData = {\n      url: `${this.url}/${resource}.json`,\n      method,\n    };\n    if (parameters)\n      if (method === 'POST') requestData.data = parameters;\n      else requestData.url += '?' + querystring.stringify(parameters);\n\n    let headers = {};\n    if (this.authType === 'User') {\n      headers = this.client.toHeader(\n        this.client.authorize(requestData, this.token)\n      );\n    } else {\n      headers = {\n        Authorization: `Bearer ${this.config.bearer_token}`,\n      };\n    }\n    return {\n      requestData,\n      headers,\n    };\n  }\n\n  /**\n   * Send a GET request\n   * @param {string} resource - endpoint, e.g. `followers/ids`\n   * @param {object} [parameters] - optional parameters\n   * @returns {Promise<object>} Promise resolving to the response from the Twitter API.\n   *   The `_header` property will be set to the Response headers (useful for checking rate limits)\n   */\n  get(resource, parameters) {\n    const { requestData, headers } = this._makeRequest(\n      'GET',\n      resource,\n      parameters\n    );\n\n    return Fetch(requestData.url, { headers })\n      .then(Twitter._handleResponse)\n      .then(results =>\n        'errors' in results ? Promise.reject(results) : results\n      );\n  }\n\n  /**\n   * Send a POST request\n   * @param {string} resource - endpoint, e.g. `users/lookup`\n   * @param {object} body - POST parameters object.\n   *   Will be encoded appropriately (JSON or urlencoded) based on the resource\n   * @returns {Promise<object>} Promise resolving to the response from the Twitter API.\n   *   The `_header` property will be set to the Response headers (useful for checking rate limits)\n   */\n  post(resource, body) {\n    const { requestData, headers } = this._makeRequest(\n      'POST',\n      resource,\n      JSON_ENDPOINTS.includes(resource) ? null : body // don't sign JSON bodies; only parameters\n    );\n\n    const postHeaders = Object.assign({}, baseHeaders, headers);\n    if (JSON_ENDPOINTS.includes(resource)) {\n      body = JSON.stringify(body);\n    } else {\n      body = percentEncode(querystring.stringify(body));\n      postHeaders['Content-Type'] = 'application/x-www-form-urlencoded';\n    }\n\n    return Fetch(requestData.url, {\n      method: 'POST',\n      headers: postHeaders,\n      body,\n    })\n      .then(Twitter._handleResponse)\n      .then(results =>\n        'errors' in results ? Promise.reject(results) : results\n      );\n  }\n\n  /**\n   *\n   * @param {string} resource - endpoint, e.g. `statuses/filter`\n   * @param {object} parameters\n   * @returns {Stream}\n   */\n  stream(resource, parameters) {\n    if (this.authType !== 'User')\n      throw new Error('Streams require user context authentication');\n\n    const stream = new Stream();\n\n    // POST the request, in order to accommodate long parameter lists, e.g.\n    // up to 5000 ids for statuses/filter - https://developer.twitter.com/en/docs/tweets/filter-realtime/api-reference/post-statuses-filter\n    const requestData = {\n      url: `${getUrl('stream')}/${resource}.json`,\n      method: 'POST',\n    };\n    if (parameters) requestData.data = parameters;\n\n    const headers = this.client.toHeader(\n      this.client.authorize(requestData, this.token)\n    );\n\n    const request = Fetch(requestData.url, {\n      method: 'POST',\n      headers: {\n        ...headers,\n        'Content-Type': 'application/x-www-form-urlencoded',\n      },\n      body: percentEncode(querystring.stringify(parameters)),\n    });\n\n    request\n      .then(response => {\n        stream.destroy = this.stream.destroy = () => response.body.destroy();\n\n        if (response.ok) {\n          stream.emit('start', response);\n        } else {\n          response._headers = response.headers;  // TODO: see #44 - could omit the line\n          stream.emit('error', response);\n        }\n\n        response.body\n          .on('data', chunk => stream.parse(chunk))\n          .on('error', error => stream.emit('error', error))  // no point in adding the original response headers\n          .on('end', () => stream.emit('end', response));\n      })\n      .catch(error => stream.emit('error', error));\n\n    return stream;\n  }\n}\n\nmodule.exports = Twitter;\n"],"names":["const","crypto","require","OAuth","Fetch","querystring","Stream","getUrl","subdomain","endpoint","defaults","consumer_key","consumer_secret","access_token_key","access_token_secret","bearer_token","JSON_ENDPOINTS","baseHeaders","Content-Type","Accept","percentEncode","string","replace","Twitter","options","ref","config","Object","assign","authType","client","consumer","signature_method","hash_function","baseString","key","createHmac","update","digest","token","url","oauth","_handleResponse","response","headers","raw","status","json","then","res","_headers","getBearerToken","Buffer","from","this","toString","$await_1","getRequestToken","twitterCallbackUrl","parameters","requestData","stringify","toHeader","authorize","text","txt","parse","$await_2","getAccessToken","verifier","secret","$await_3","_makeRequest","method","resource","data","get","results","Promise","reject","post","body","includes","postHeaders","JSON","stream","Error","destroy","ok","emit","on","chunk","error","catch","module","exports"],"mappings":"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"}
\ No newline at end of file
diff --git a/node_modules/twitter-lite/dist/twitter.m.js b/node_modules/twitter-lite/dist/twitter.m.js
index 28ad0dc..8a180d3 100644
--- a/node_modules/twitter-lite/dist/twitter.m.js
+++ b/node_modules/twitter-lite/dist/twitter.m.js
@@ -1,2 +1,2 @@
-var e=require("crypto"),t=require("oauth-1.0a"),r=require("cross-fetch"),n=require("querystring"),s=require("./stream"),o=function(e,t){return void 0===t&&(t="1.1"),"https://"+e+".twitter.com/"+t},i={subdomain:"api",consumer_key:null,consumer_secret:null,access_token_key:null,access_token_secret:null,bearer_token:null},a=["direct_messages/events/new","direct_messages/welcome_messages/new","direct_messages/welcome_messages/rules/new"],u={"Content-Type":"application/json",Accept:"application/json"};function c(e){return e.replace(/!/g,"%21").replace(/\*/g,"%2A").replace(/'/g,"%27").replace(/\(/g,"%28").replace(/\)/g,"%29")}var h=function(r){var n,s=Object.assign({},i,r);this.authType=s.bearer_token?"App":"User",this.client=t({consumer:{key:(n={key:s.consumer_key,secret:s.consumer_secret}).key,secret:n.secret},signature_method:"HMAC-SHA1",hash_function:function(t,r){return e.createHmac("sha1",r).update(t).digest("base64")}}),this.token={key:s.access_token_key,secret:s.access_token_secret},this.url=o(s.subdomain),this.oauth=o(s.subdomain,"oauth"),this.config=s};h._handleResponse=function(e){var t=e.headers.raw();return 204===e.status?{_headers:t}:e.json().then(function(e){return e._headers=t,e})},h.prototype.getBearerToken=function(){return new Promise(function(e,t){var n;return n={Authorization:"Basic "+Buffer.from(this.config.consumer_key+":"+this.config.consumer_secret).toString("base64"),"Content-Type":"application/x-www-form-urlencoded;charset=UTF-8"},r("https://api.twitter.com/oauth2/token",{method:"POST",body:"grant_type=client_credentials",headers:n}).then(h._handleResponse).then(function(r){try{return e(r)}catch(e){return t(e)}},t)}.bind(this))},h.prototype.getRequestToken=function(e){return new Promise(function(t,s){var o,i,a;return o={url:this.oauth+"/request_token",method:"POST"},i={},e&&(i={oauth_callback:e}),i&&(o.url+="?"+n.stringify(i)),a=this.client.toHeader(this.client.authorize(o,{})),r(o.url,{method:"POST",headers:Object.assign({},u,a)}).then(function(e){return e.text()}).then(function(e){return n.parse(e)}).then(function(e){try{return t(e)}catch(e){return s(e)}},s)}.bind(this))},h.prototype.getAccessToken=function(e){return new Promise(function(t,s){var o,i,a;return o={url:this.oauth+"/access_token",method:"POST"},(i={oauth_verifier:e.verifier})&&(o.url+="?"+n.stringify(i)),a=this.client.toHeader(this.client.authorize(o,{key:e.key,secret:e.secret})),r(o.url,{method:"POST",headers:Object.assign({},u,a)}).then(function(e){return e.text()}).then(function(e){return n.parse(e)}).then(function(e){try{return t(e)}catch(e){return s(e)}},s)}.bind(this))},h.prototype._makeRequest=function(e,t,r){var s={url:this.url+"/"+t+".json",method:e};r&&("POST"===e?s.data=r:s.url+="?"+n.stringify(r));return{requestData:s,headers:"User"===this.authType?this.client.toHeader(this.client.authorize(s,this.token)):{Authorization:"Bearer "+this.config.bearer_token}}},h.prototype.get=function(e,t){var n=this._makeRequest("GET",e,t);return r(n.requestData.url,{headers:n.headers}).then(h._handleResponse).then(function(e){return"errors"in e?Promise.reject(e):e})},h.prototype.post=function(e,t){var s=this._makeRequest("POST",e,a.includes(e)?null:t),o=s.requestData,i=Object.assign({},u,s.headers);return a.includes(e)?t=JSON.stringify(t):(t=c(n.stringify(t)),i["Content-Type"]="application/x-www-form-urlencoded"),r(o.url,{method:"POST",headers:i,body:t}).then(h._handleResponse).then(function(e){return"errors"in e?Promise.reject(e):e})},h.prototype.stream=function(e,t){var i=this;if("User"!==this.authType)throw new Error("Streams require user context authentication");var a=new s,u={url:o("stream")+"/"+e+".json",method:"POST"};t&&(u.data=t);var h=this.client.toHeader(this.client.authorize(u,this.token));return r(u.url,{method:"POST",headers:Object.assign({},h,{"Content-Type":"application/x-www-form-urlencoded"}),body:c(n.stringify(t))}).then(function(e){a.destroy=i.stream.destroy=function(){return e.body.destroy()},e.ok?a.emit("start",e):(e._headers=e.headers.raw(),a.emit("error",e)),e.body.on("data",function(e){return a.parse(e)}).on("error",function(e){return a.emit("error",e)}).on("end",function(){return a.emit("end",e)})}).catch(function(e){return a.emit("error",e)}),a},module.exports=h;
+var e=require("crypto"),t=require("oauth-1.0a"),r=require("cross-fetch"),n=require("querystring"),s=require("./stream"),o=function(e,t){return void 0===t&&(t="1.1"),"https://"+e+".twitter.com/"+t},i={subdomain:"api",consumer_key:null,consumer_secret:null,access_token_key:null,access_token_secret:null,bearer_token:null},a=["direct_messages/events/new","direct_messages/welcome_messages/new","direct_messages/welcome_messages/rules/new"],u={"Content-Type":"application/json",Accept:"application/json"};function c(e){return e.replace(/!/g,"%21").replace(/\*/g,"%2A").replace(/'/g,"%27").replace(/\(/g,"%28").replace(/\)/g,"%29")}var h=function(r){var n,s=Object.assign({},i,r);this.authType=s.bearer_token?"App":"User",this.client=t({consumer:{key:(n={key:s.consumer_key,secret:s.consumer_secret}).key,secret:n.secret},signature_method:"HMAC-SHA1",hash_function:function(t,r){return e.createHmac("sha1",r).update(t).digest("base64")}}),this.token={key:s.access_token_key,secret:s.access_token_secret},this.url=o(s.subdomain),this.oauth=o(s.subdomain,"oauth"),this.config=s};h._handleResponse=function(e){var t=e.headers;return 204===e.status?{_headers:t}:e.json().then(function(e){return e._headers=t,e})},h.prototype.getBearerToken=function(){return new Promise(function(e,t){var n;return n={Authorization:"Basic "+Buffer.from(this.config.consumer_key+":"+this.config.consumer_secret).toString("base64"),"Content-Type":"application/x-www-form-urlencoded;charset=UTF-8"},r("https://api.twitter.com/oauth2/token",{method:"POST",body:"grant_type=client_credentials",headers:n}).then(h._handleResponse).then(function(r){try{return e(r)}catch(e){return t(e)}},t)}.bind(this))},h.prototype.getRequestToken=function(e){return new Promise(function(t,s){var o,i,a;return o={url:this.oauth+"/request_token",method:"POST"},i={},e&&(i={oauth_callback:e}),i&&(o.url+="?"+n.stringify(i)),a=this.client.toHeader(this.client.authorize(o,{})),r(o.url,{method:"POST",headers:Object.assign({},u,a)}).then(function(e){return e.text()}).then(function(e){return n.parse(e)}).then(function(e){try{return t(e)}catch(e){return s(e)}},s)}.bind(this))},h.prototype.getAccessToken=function(e){return new Promise(function(t,s){var o,i,a;return o={url:this.oauth+"/access_token",method:"POST"},(i={oauth_verifier:e.verifier})&&(o.url+="?"+n.stringify(i)),a=this.client.toHeader(this.client.authorize(o,{key:e.key,secret:e.secret})),r(o.url,{method:"POST",headers:Object.assign({},u,a)}).then(function(e){return e.text()}).then(function(e){return n.parse(e)}).then(function(e){try{return t(e)}catch(e){return s(e)}},s)}.bind(this))},h.prototype._makeRequest=function(e,t,r){var s={url:this.url+"/"+t+".json",method:e};r&&("POST"===e?s.data=r:s.url+="?"+n.stringify(r));return{requestData:s,headers:"User"===this.authType?this.client.toHeader(this.client.authorize(s,this.token)):{Authorization:"Bearer "+this.config.bearer_token}}},h.prototype.get=function(e,t){var n=this._makeRequest("GET",e,t);return r(n.requestData.url,{headers:n.headers}).then(h._handleResponse).then(function(e){return"errors"in e?Promise.reject(e):e})},h.prototype.post=function(e,t){var s=this._makeRequest("POST",e,a.includes(e)?null:t),o=s.requestData,i=Object.assign({},u,s.headers);return a.includes(e)?t=JSON.stringify(t):(t=c(n.stringify(t)),i["Content-Type"]="application/x-www-form-urlencoded"),r(o.url,{method:"POST",headers:i,body:t}).then(h._handleResponse).then(function(e){return"errors"in e?Promise.reject(e):e})},h.prototype.stream=function(e,t){var i=this;if("User"!==this.authType)throw new Error("Streams require user context authentication");var a=new s,u={url:o("stream")+"/"+e+".json",method:"POST"};t&&(u.data=t);var h=this.client.toHeader(this.client.authorize(u,this.token));return r(u.url,{method:"POST",headers:Object.assign({},h,{"Content-Type":"application/x-www-form-urlencoded"}),body:c(n.stringify(t))}).then(function(e){a.destroy=i.stream.destroy=function(){return e.body.destroy()},e.ok?a.emit("start",e):(e._headers=e.headers,a.emit("error",e)),e.body.on("data",function(e){return a.parse(e)}).on("error",function(e){return a.emit("error",e)}).on("end",function(){return a.emit("end",e)})}).catch(function(e){return a.emit("error",e)}),a},module.exports=h;
 //# sourceMappingURL=twitter.m.js.map
diff --git a/node_modules/twitter-lite/dist/twitter.m.js.map b/node_modules/twitter-lite/dist/twitter.m.js.map
index 4b7b9f7..58c6f29 100644
--- a/node_modules/twitter-lite/dist/twitter.m.js.map
+++ b/node_modules/twitter-lite/dist/twitter.m.js.map
@@ -1 +1 @@
-{"version":3,"file":"twitter.m.js","sources":["../twitter.js"],"sourcesContent":["const crypto = require('crypto');\nconst OAuth = require('oauth-1.0a');\nconst Fetch = require('cross-fetch');\nconst querystring = require('querystring');\nconst Stream = require('./stream');\n\nconst getUrl = (subdomain, endpoint = '1.1') =>\n  `https://${subdomain}.twitter.com/${endpoint}`;\n\nconst createOauthClient = ({ key, secret }) => {\n  const client = OAuth({\n    consumer: { key, secret },\n    signature_method: 'HMAC-SHA1',\n    hash_function(baseString, key) {\n      return crypto\n        .createHmac('sha1', key)\n        .update(baseString)\n        .digest('base64');\n    },\n  });\n\n  return client;\n};\n\nconst defaults = {\n  subdomain: 'api',\n  consumer_key: null,\n  consumer_secret: null,\n  access_token_key: null,\n  access_token_secret: null,\n  bearer_token: null,\n};\n\n// Twitter expects POST body parameters to be URL-encoded: https://developer.twitter.com/en/docs/basics/authentication/guides/creating-a-signature\n// However, some endpoints expect a JSON payload - https://developer.twitter.com/en/docs/direct-messages/sending-and-receiving/api-reference/new-event\n// It appears that JSON payloads don't need to be included in the signature,\n// because sending DMs works without signing the POST body\nconst JSON_ENDPOINTS = [\n  'direct_messages/events/new',\n  'direct_messages/welcome_messages/new',\n  'direct_messages/welcome_messages/rules/new',\n];\n\nconst baseHeaders = {\n  'Content-Type': 'application/json',\n  Accept: 'application/json',\n};\n\nfunction percentEncode(string) {\n  // From OAuth.prototype.percentEncode\n  return string\n    .replace(/!/g, '%21')\n    .replace(/\\*/g, '%2A')\n    .replace(/'/g, '%27')\n    .replace(/\\(/g, '%28')\n    .replace(/\\)/g, '%29');\n}\n\nclass Twitter {\n  constructor(options) {\n    const config = Object.assign({}, defaults, options);\n    this.authType = config.bearer_token ? 'App' : 'User';\n    this.client = createOauthClient({\n      key: config.consumer_key,\n      secret: config.consumer_secret,\n    });\n\n    this.token = {\n      key: config.access_token_key,\n      secret: config.access_token_secret,\n    };\n\n    this.url = getUrl(config.subdomain);\n    this.oauth = getUrl(config.subdomain, 'oauth');\n    this.config = config;\n  }\n\n  /**\n   * Parse the JSON from a Response object and add the Headers under `_headers`\n   * @param {Response} response - the Response object returned by Fetch\n   * @return {Promise<object>}\n   * @private\n   */\n  static _handleResponse(response) {\n    const headers = response.headers.raw(); // TODO: see #44\n    // Return empty response on 204 \"No content\"\n    if (response.status === 204)\n      return {\n        _headers: headers,\n      };\n    // Otherwise, parse JSON response\n    return response.json().then(res => {\n      res._headers = headers; // TODO: this creates an array-like object when it adds _headers to an array response\n      return res;\n    });\n  }\n\n  async getBearerToken() {\n    const headers = {\n      Authorization:\n        'Basic ' +\n        Buffer.from(\n          this.config.consumer_key + ':' + this.config.consumer_secret\n        ).toString('base64'),\n      'Content-Type': 'application/x-www-form-urlencoded;charset=UTF-8',\n    };\n\n    const results = await Fetch('https://api.twitter.com/oauth2/token', {\n      method: 'POST',\n      body: 'grant_type=client_credentials',\n      headers,\n    }).then(Twitter._handleResponse);\n\n    return results;\n  }\n\n  async getRequestToken(twitterCallbackUrl) {\n    const requestData = {\n      url: `${this.oauth}/request_token`,\n      method: 'POST',\n    };\n\n    let parameters = {};\n    if (twitterCallbackUrl) parameters = { oauth_callback: twitterCallbackUrl };\n    if (parameters) requestData.url += '?' + querystring.stringify(parameters);\n\n    const headers = this.client.toHeader(\n      this.client.authorize(requestData, {})\n    );\n\n    const results = await Fetch(requestData.url, {\n      method: 'POST',\n      headers: Object.assign({}, baseHeaders, headers),\n    })\n      .then(res => res.text())\n      .then(txt => querystring.parse(txt));\n\n    return results;\n  }\n\n  async getAccessToken(options) {\n    const requestData = {\n      url: `${this.oauth}/access_token`,\n      method: 'POST',\n    };\n\n    let parameters = { oauth_verifier: options.verifier };\n    if (parameters) requestData.url += '?' + querystring.stringify(parameters);\n\n    const headers = this.client.toHeader(\n      this.client.authorize(requestData, {\n        key: options.key,\n        secret: options.secret,\n      })\n    );\n\n    const results = await Fetch(requestData.url, {\n      method: 'POST',\n      headers: Object.assign({}, baseHeaders, headers),\n    })\n      .then(res => res.text())\n      .then(txt => querystring.parse(txt));\n\n    return results;\n  }\n\n  /**\n   * Construct the data and headers for an authenticated HTTP request to the Twitter API\n   * @param {string} method - 'GET' or 'POST'\n   * @param {string} resource - the API endpoint\n   * @param {object} parameters\n   * @return {{requestData: {url: string, method: string}, headers: ({Authorization: string}|OAuth.Header)}}\n   * @private\n   */\n  _makeRequest(method, resource, parameters) {\n    const requestData = {\n      url: `${this.url}/${resource}.json`,\n      method,\n    };\n    if (parameters)\n      if (method === 'POST') requestData.data = parameters;\n      else requestData.url += '?' + querystring.stringify(parameters);\n\n    let headers = {};\n    if (this.authType === 'User') {\n      headers = this.client.toHeader(\n        this.client.authorize(requestData, this.token)\n      );\n    } else {\n      headers = {\n        Authorization: `Bearer ${this.config.bearer_token}`,\n      };\n    }\n    return {\n      requestData,\n      headers,\n    };\n  }\n\n  /**\n   * Send a GET request\n   * @param {string} resource - endpoint, e.g. `followers/ids`\n   * @param {object} [parameters] - optional parameters\n   * @returns {Promise<object>} Promise resolving to the response from the Twitter API.\n   *   The `_header` property will be set to the Response headers (useful for checking rate limits)\n   */\n  get(resource, parameters) {\n    const { requestData, headers } = this._makeRequest(\n      'GET',\n      resource,\n      parameters\n    );\n\n    return Fetch(requestData.url, { headers })\n      .then(Twitter._handleResponse)\n      .then(results =>\n        'errors' in results ? Promise.reject(results) : results\n      );\n  }\n\n  /**\n   * Send a POST request\n   * @param {string} resource - endpoint, e.g. `users/lookup`\n   * @param {object} body - POST parameters object.\n   *   Will be encoded appropriately (JSON or urlencoded) based on the resource\n   * @returns {Promise<object>} Promise resolving to the response from the Twitter API.\n   *   The `_header` property will be set to the Response headers (useful for checking rate limits)\n   */\n  post(resource, body) {\n    const { requestData, headers } = this._makeRequest(\n      'POST',\n      resource,\n      JSON_ENDPOINTS.includes(resource) ? null : body // don't sign JSON bodies; only parameters\n    );\n\n    const postHeaders = Object.assign({}, baseHeaders, headers);\n    if (JSON_ENDPOINTS.includes(resource)) {\n      body = JSON.stringify(body);\n    } else {\n      body = percentEncode(querystring.stringify(body));\n      postHeaders['Content-Type'] = 'application/x-www-form-urlencoded';\n    }\n\n    return Fetch(requestData.url, {\n      method: 'POST',\n      headers: postHeaders,\n      body,\n    })\n      .then(Twitter._handleResponse)\n      .then(results =>\n        'errors' in results ? Promise.reject(results) : results\n      );\n  }\n\n  /**\n   *\n   * @param {string} resource - endpoint, e.g. `statuses/filter`\n   * @param {object} parameters\n   * @returns {Stream}\n   */\n  stream(resource, parameters) {\n    if (this.authType !== 'User')\n      throw new Error('Streams require user context authentication');\n\n    const stream = new Stream();\n\n    // POST the request, in order to accommodate long parameter lists, e.g.\n    // up to 5000 ids for statuses/filter - https://developer.twitter.com/en/docs/tweets/filter-realtime/api-reference/post-statuses-filter\n    const requestData = {\n      url: `${getUrl('stream')}/${resource}.json`,\n      method: 'POST',\n    };\n    if (parameters) requestData.data = parameters;\n\n    const headers = this.client.toHeader(\n      this.client.authorize(requestData, this.token)\n    );\n\n    const request = Fetch(requestData.url, {\n      method: 'POST',\n      headers: {\n        ...headers,\n        'Content-Type': 'application/x-www-form-urlencoded',\n      },\n      body: percentEncode(querystring.stringify(parameters)),\n    });\n\n    request\n      .then(response => {\n        stream.destroy = this.stream.destroy = () => response.body.destroy();\n\n        if (response.ok) {\n          stream.emit('start', response);\n        } else {\n          response._headers = response.headers.raw();  // TODO: see #44 - could omit the line\n          stream.emit('error', response);\n        }\n\n        response.body\n          .on('data', chunk => stream.parse(chunk))\n          .on('error', error => stream.emit('error', error))  // no point in adding the original response headers\n          .on('end', () => stream.emit('end', response));\n      })\n      .catch(error => stream.emit('error', error));\n\n    return stream;\n  }\n}\n\nmodule.exports = Twitter;\n"],"names":["const","crypto","require","OAuth","Fetch","querystring","Stream","getUrl","subdomain","endpoint","defaults","consumer_key","consumer_secret","access_token_key","access_token_secret","bearer_token","JSON_ENDPOINTS","baseHeaders","Content-Type","Accept","percentEncode","string","replace","Twitter","options","ref","config","Object","assign","authType","client","consumer","signature_method","hash_function","baseString","key","createHmac","update","digest","token","url","oauth","_handleResponse","response","headers","raw","status","json","then","res","_headers","getBearerToken","Buffer","from","this","toString","$await_1","getRequestToken","twitterCallbackUrl","parameters","requestData","stringify","toHeader","authorize","text","txt","parse","$await_2","getAccessToken","verifier","secret","$await_3","_makeRequest","method","resource","data","get","results","Promise","reject","post","body","includes","postHeaders","JSON","stream","Error","destroy","ok","emit","on","chunk","error","catch","module","exports"],"mappings":"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"}
\ No newline at end of file
+{"version":3,"file":"twitter.m.js","sources":["../twitter.js"],"sourcesContent":["const crypto = require('crypto');\nconst OAuth = require('oauth-1.0a');\nconst Fetch = require('cross-fetch');\nconst querystring = require('querystring');\nconst Stream = require('./stream');\n\nconst getUrl = (subdomain, endpoint = '1.1') =>\n  `https://${subdomain}.twitter.com/${endpoint}`;\n\nconst createOauthClient = ({ key, secret }) => {\n  const client = OAuth({\n    consumer: { key, secret },\n    signature_method: 'HMAC-SHA1',\n    hash_function(baseString, key) {\n      return crypto\n        .createHmac('sha1', key)\n        .update(baseString)\n        .digest('base64');\n    },\n  });\n\n  return client;\n};\n\nconst defaults = {\n  subdomain: 'api',\n  consumer_key: null,\n  consumer_secret: null,\n  access_token_key: null,\n  access_token_secret: null,\n  bearer_token: null,\n};\n\n// Twitter expects POST body parameters to be URL-encoded: https://developer.twitter.com/en/docs/basics/authentication/guides/creating-a-signature\n// However, some endpoints expect a JSON payload - https://developer.twitter.com/en/docs/direct-messages/sending-and-receiving/api-reference/new-event\n// It appears that JSON payloads don't need to be included in the signature,\n// because sending DMs works without signing the POST body\nconst JSON_ENDPOINTS = [\n  'direct_messages/events/new',\n  'direct_messages/welcome_messages/new',\n  'direct_messages/welcome_messages/rules/new',\n];\n\nconst baseHeaders = {\n  'Content-Type': 'application/json',\n  Accept: 'application/json',\n};\n\nfunction percentEncode(string) {\n  // From OAuth.prototype.percentEncode\n  return string\n    .replace(/!/g, '%21')\n    .replace(/\\*/g, '%2A')\n    .replace(/'/g, '%27')\n    .replace(/\\(/g, '%28')\n    .replace(/\\)/g, '%29');\n}\n\nclass Twitter {\n  constructor(options) {\n    const config = Object.assign({}, defaults, options);\n    this.authType = config.bearer_token ? 'App' : 'User';\n    this.client = createOauthClient({\n      key: config.consumer_key,\n      secret: config.consumer_secret,\n    });\n\n    this.token = {\n      key: config.access_token_key,\n      secret: config.access_token_secret,\n    };\n\n    this.url = getUrl(config.subdomain);\n    this.oauth = getUrl(config.subdomain, 'oauth');\n    this.config = config;\n  }\n\n  /**\n   * Parse the JSON from a Response object and add the Headers under `_headers`\n   * @param {Response} response - the Response object returned by Fetch\n   * @return {Promise<object>}\n   * @private\n   */\n  static _handleResponse(response) {\n    const headers = response.headers; // TODO: see #44\n    // Return empty response on 204 \"No content\"\n    if (response.status === 204)\n      return {\n        _headers: headers,\n      };\n    // Otherwise, parse JSON response\n    return response.json().then(res => {\n      res._headers = headers; // TODO: this creates an array-like object when it adds _headers to an array response\n      return res;\n    });\n  }\n\n  async getBearerToken() {\n    const headers = {\n      Authorization:\n        'Basic ' +\n        Buffer.from(\n          this.config.consumer_key + ':' + this.config.consumer_secret\n        ).toString('base64'),\n      'Content-Type': 'application/x-www-form-urlencoded;charset=UTF-8',\n    };\n\n    const results = await Fetch('https://api.twitter.com/oauth2/token', {\n      method: 'POST',\n      body: 'grant_type=client_credentials',\n      headers,\n    }).then(Twitter._handleResponse);\n\n    return results;\n  }\n\n  async getRequestToken(twitterCallbackUrl) {\n    const requestData = {\n      url: `${this.oauth}/request_token`,\n      method: 'POST',\n    };\n\n    let parameters = {};\n    if (twitterCallbackUrl) parameters = { oauth_callback: twitterCallbackUrl };\n    if (parameters) requestData.url += '?' + querystring.stringify(parameters);\n\n    const headers = this.client.toHeader(\n      this.client.authorize(requestData, {})\n    );\n\n    const results = await Fetch(requestData.url, {\n      method: 'POST',\n      headers: Object.assign({}, baseHeaders, headers),\n    })\n      .then(res => res.text())\n      .then(txt => querystring.parse(txt));\n\n    return results;\n  }\n\n  async getAccessToken(options) {\n    const requestData = {\n      url: `${this.oauth}/access_token`,\n      method: 'POST',\n    };\n\n    let parameters = { oauth_verifier: options.verifier };\n    if (parameters) requestData.url += '?' + querystring.stringify(parameters);\n\n    const headers = this.client.toHeader(\n      this.client.authorize(requestData, {\n        key: options.key,\n        secret: options.secret,\n      })\n    );\n\n    const results = await Fetch(requestData.url, {\n      method: 'POST',\n      headers: Object.assign({}, baseHeaders, headers),\n    })\n      .then(res => res.text())\n      .then(txt => querystring.parse(txt));\n\n    return results;\n  }\n\n  /**\n   * Construct the data and headers for an authenticated HTTP request to the Twitter API\n   * @param {string} method - 'GET' or 'POST'\n   * @param {string} resource - the API endpoint\n   * @param {object} parameters\n   * @return {{requestData: {url: string, method: string}, headers: ({Authorization: string}|OAuth.Header)}}\n   * @private\n   */\n  _makeRequest(method, resource, parameters) {\n    const requestData = {\n      url: `${this.url}/${resource}.json`,\n      method,\n    };\n    if (parameters)\n      if (method === 'POST') requestData.data = parameters;\n      else requestData.url += '?' + querystring.stringify(parameters);\n\n    let headers = {};\n    if (this.authType === 'User') {\n      headers = this.client.toHeader(\n        this.client.authorize(requestData, this.token)\n      );\n    } else {\n      headers = {\n        Authorization: `Bearer ${this.config.bearer_token}`,\n      };\n    }\n    return {\n      requestData,\n      headers,\n    };\n  }\n\n  /**\n   * Send a GET request\n   * @param {string} resource - endpoint, e.g. `followers/ids`\n   * @param {object} [parameters] - optional parameters\n   * @returns {Promise<object>} Promise resolving to the response from the Twitter API.\n   *   The `_header` property will be set to the Response headers (useful for checking rate limits)\n   */\n  get(resource, parameters) {\n    const { requestData, headers } = this._makeRequest(\n      'GET',\n      resource,\n      parameters\n    );\n\n    return Fetch(requestData.url, { headers })\n      .then(Twitter._handleResponse)\n      .then(results =>\n        'errors' in results ? Promise.reject(results) : results\n      );\n  }\n\n  /**\n   * Send a POST request\n   * @param {string} resource - endpoint, e.g. `users/lookup`\n   * @param {object} body - POST parameters object.\n   *   Will be encoded appropriately (JSON or urlencoded) based on the resource\n   * @returns {Promise<object>} Promise resolving to the response from the Twitter API.\n   *   The `_header` property will be set to the Response headers (useful for checking rate limits)\n   */\n  post(resource, body) {\n    const { requestData, headers } = this._makeRequest(\n      'POST',\n      resource,\n      JSON_ENDPOINTS.includes(resource) ? null : body // don't sign JSON bodies; only parameters\n    );\n\n    const postHeaders = Object.assign({}, baseHeaders, headers);\n    if (JSON_ENDPOINTS.includes(resource)) {\n      body = JSON.stringify(body);\n    } else {\n      body = percentEncode(querystring.stringify(body));\n      postHeaders['Content-Type'] = 'application/x-www-form-urlencoded';\n    }\n\n    return Fetch(requestData.url, {\n      method: 'POST',\n      headers: postHeaders,\n      body,\n    })\n      .then(Twitter._handleResponse)\n      .then(results =>\n        'errors' in results ? Promise.reject(results) : results\n      );\n  }\n\n  /**\n   *\n   * @param {string} resource - endpoint, e.g. `statuses/filter`\n   * @param {object} parameters\n   * @returns {Stream}\n   */\n  stream(resource, parameters) {\n    if (this.authType !== 'User')\n      throw new Error('Streams require user context authentication');\n\n    const stream = new Stream();\n\n    // POST the request, in order to accommodate long parameter lists, e.g.\n    // up to 5000 ids for statuses/filter - https://developer.twitter.com/en/docs/tweets/filter-realtime/api-reference/post-statuses-filter\n    const requestData = {\n      url: `${getUrl('stream')}/${resource}.json`,\n      method: 'POST',\n    };\n    if (parameters) requestData.data = parameters;\n\n    const headers = this.client.toHeader(\n      this.client.authorize(requestData, this.token)\n    );\n\n    const request = Fetch(requestData.url, {\n      method: 'POST',\n      headers: {\n        ...headers,\n        'Content-Type': 'application/x-www-form-urlencoded',\n      },\n      body: percentEncode(querystring.stringify(parameters)),\n    });\n\n    request\n      .then(response => {\n        stream.destroy = this.stream.destroy = () => response.body.destroy();\n\n        if (response.ok) {\n          stream.emit('start', response);\n        } else {\n          response._headers = response.headers;  // TODO: see #44 - could omit the line\n          stream.emit('error', response);\n        }\n\n        response.body\n          .on('data', chunk => stream.parse(chunk))\n          .on('error', error => stream.emit('error', error))  // no point in adding the original response headers\n          .on('end', () => stream.emit('end', response));\n      })\n      .catch(error => stream.emit('error', error));\n\n    return stream;\n  }\n}\n\nmodule.exports = Twitter;\n"],"names":["const","crypto","require","OAuth","Fetch","querystring","Stream","getUrl","subdomain","endpoint","defaults","consumer_key","consumer_secret","access_token_key","access_token_secret","bearer_token","JSON_ENDPOINTS","baseHeaders","Content-Type","Accept","percentEncode","string","replace","Twitter","options","ref","config","Object","assign","authType","client","consumer","signature_method","hash_function","baseString","key","createHmac","update","digest","token","url","oauth","_handleResponse","response","headers","raw","status","json","then","res","_headers","getBearerToken","Buffer","from","this","toString","$await_1","getRequestToken","twitterCallbackUrl","parameters","requestData","stringify","toHeader","authorize","text","txt","parse","$await_2","getAccessToken","verifier","secret","$await_3","_makeRequest","method","resource","data","get","results","Promise","reject","post","body","includes","postHeaders","JSON","stream","Error","destroy","ok","emit","on","chunk","error","catch","module","exports"],"mappings":"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"}
\ No newline at end of file
diff --git a/node_modules/twitter-lite/twitter.js b/node_modules/twitter-lite/twitter.js
index 23096f0..ff7e8b6 100644
--- a/node_modules/twitter-lite/twitter.js
+++ b/node_modules/twitter-lite/twitter.js
@@ -82,7 +82,7 @@ class Twitter {
    * @private
    */
   static _handleResponse(response) {
-    const headers = response.headers.raw(); // TODO: see #44
+    const headers = response.headers; // TODO: see #44
     // Return empty response on 204 "No content"
     if (response.status === 204)
       return {
@@ -292,7 +292,7 @@ class Twitter {
         if (response.ok) {
           stream.emit('start', response);
         } else {
-          response._headers = response.headers.raw();  // TODO: see #44 - could omit the line
+          response._headers = response.headers;  // TODO: see #44 - could omit the line
           stream.emit('error', response);
         }
 
